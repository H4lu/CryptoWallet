import {app, BrowserWindow, ipcMain, session, Filter} from 'electron';
import {fork, ChildProcess} from 'child_process'

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;

let mainWindow: BrowserWindow
let pcscProcess: ChildProcess

ipcMain.once('close', () => {
    mainWindow.close()
})

ipcMain.on('hide', () => {
    mainWindow.minimize()
})

ipcMain.on('pcsc', (event, data) => {
    console.log("pcsc data")
    console.log(data)
    if (pcscProcess != undefined) {
        pcscProcess.send(data)
    }
})
app.disableHardwareAcceleration()
app.allowRendererProcessReuse = false
app.commandLine.appendSwitch('disable-features', 'OutOfBlinkCors')
app.commandLine.appendSwitch('disable-site-isolation-trials')
// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) { // eslint-disable-line global-require
    app.quit();
}

console.log('CREATE WINDOW')
const createWindow = (): void => {
    // Create the browser window.
    mainWindow = new BrowserWindow({
        width: 1366,
        height: 821,
        resizable: false,
        fullscreen: false,
        frame: false,
        webPreferences: {
            nodeIntegration: true,
            contextIsolation: false,
            enableBlinkFeatures: 'OutOfBlinkCors',
            webSecurity: false,
            enableRemoteModule: true
        }
    });


    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    mainWindow.once('ready-to-show', () => {
        console.log('PROCESS CWD:')
        console.log(process.cwd())
        console.log("FORK")
        const processPath = process.env.NODE_ENV == 'production' ? "resources/app/.webpack/main/pcsc.js" : ".webpack/main/pcsc.js"
        pcscProcess = fork(processPath, {
            stdio: ['ipc'],
            silent: true,
            detached: true
        });
        pcscProcess.on('error', err => {
            console.log("CHILD ERRPR ", err.message)
        })
        pcscProcess.on('exit', code => {
            console.log("EXITED CHILD CODE: ", code)
            pcscProcess.kill()
        })
        pcscProcess.on('message', msg => {
            console.log('child message');
            console.log(msg);
            mainWindow.webContents.send('pcsc', msg)
        })
        process.stderr.on('data', data => {
            console.log("stderr: ", data.toString())
        })
        pcscProcess.stdout.on('data', data => {
            console.log('pcsc stdout ', data.toString());
        })
        pcscProcess.stdout.on('error', err => {
            console.log('pcsc stderr: ', err.message)
        })
    })

    // Open the DevTools.
    if (process.env.NODE_ENV == 'development') {
        mainWindow.webContents.openDevTools();
    }

};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);
app.on('quit', () => {
    if (pcscProcess != undefined) {
        pcscProcess.kill()
    }
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

app.on('activate', () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
